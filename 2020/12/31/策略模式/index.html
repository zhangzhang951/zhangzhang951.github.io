<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>策略模式 | 张心蕊的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="策略模式 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。   在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。   如果使用多重条件转移语">
<meta property="og:type" content="article">
<meta property="og:title" content="策略模式">
<meta property="og:url" content="http://example.com/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="张心蕊的博客">
<meta property="og:description" content="策略模式 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。   在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。   如果使用多重条件转移语">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-31T05:42:05.446Z">
<meta property="article:modified_time" content="2020-12-31T06:03:40.893Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张心蕊的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张心蕊的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-策略模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T05:42:05.446Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      策略模式
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><pre><code> 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。

 在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。

 如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决这些问题。</code></pre>
<h3 id="1-策略模式的定义与特点"><a href="#1-策略模式的定义与特点" class="headerlink" title="1.策略模式的定义与特点"></a>1.策略模式的定义与特点</h3><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p><strong>简述：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</strong></p>
<p>策略模式的主要优点如下。</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>
</ol>
<h3 id="2-鸭子问题"><a href="#2-鸭子问题" class="headerlink" title="2.鸭子问题"></a>2.鸭子问题</h3><p><strong>模拟鸭子项目，具体要求如下：</strong></p>
<p>1）有各种鸭子（比如 绿头鸭、红头鸭，鸭子有各种行为，比如叫、游泳）</p>
<p>2）显示鸭子的信息</p>
<p><strong>传统方案解决鸭子问题的分析和代码实现</strong></p>
<p>1）传统的设计方案</p>
<p>2）代码实现</p>
<p><strong>.java文件说明：</strong><br>Duck.java:基类鸭子<br>GreenHeadDuck.java:绿头鸭<br>RedHeadDuck.java:红头鸭<br>SimulateDuck.java:模拟鸭子（main）</p>
<p>Duck.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象类：鸭子</span><br><span class="line">public  abstract class Duck &#123;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        &#x2F;&#x2F;子类的构造函数中可以定义行为</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中已经实现了</span><br><span class="line">    public void quack()&#123;</span><br><span class="line">        System.out.println(&quot;~~嘎嘎叫~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由子类实现</span><br><span class="line">    public abstract void display();</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中自己已经实现了</span><br><span class="line">    public void swim()&#123;</span><br><span class="line">        System.out.println(&quot;~~我会游泳~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RedHeadDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class RedHeadDuck extends Duck&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我是独一无二的,我的头是红色的&quot;);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GreenHeadDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GreenHeadDuck extends Duck &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我和你们不一样，我的头是绿色的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SimulateDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GreenHeadDuck greenHeadDuck&#x3D;new GreenHeadDuck();</span><br><span class="line">   RedHeadDuck redHeadDuck&#x3D;new RedHeadDuck();</span><br><span class="line"></span><br><span class="line">   greenHeadDuck.display();</span><br><span class="line">   greenHeadDuck.quack();</span><br><span class="line">   greenHeadDuck.swim();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   redHeadDuck.display();</span><br><span class="line">   redHeadDuck.quack();</span><br><span class="line">   redHeadDuck.swim();</span><br></pre></td></tr></table></figure>
<p>我们已经实现了基本的项目需求了。模拟鸭子算是成功啦~！</p>
<p>但是项目添加了<strong>新的需求</strong>，添加会飞的鸭子（并不是所有的鸭子都会飞）</p>
<p><strong>传统的方式实现的问题分析和解决方案</strong></p>
<ul>
<li><p>如果在基类写Fly()方法，其他鸭子，都继承了Duck类，所以fly让所有子类都会飞了，违背逻辑。</p>
</li>
<li><p>这个问题，是继承带来的问题，对类的局部改动，尤其超类的局部改动，会影响其他部分，会有溢出效应</p>
</li>
<li><p>为了改进问题，我们可以通过覆盖fly方法来解决，</p>
</li>
<li><p>问题又来了，如果我们有一个玩具鸭子,这样需要玩具鸭子去覆盖Duck的所有实现的方法 ，覆盖工作量特别大</p>
</li>
<li><p> <em>解决方法：<u>策略模式</u>（strategy pattern）<strong>思路：继承是实现共性，减少代码的重复。接口是实现特性。</strong></em></p>
</li>
</ul>
<h3 id="3-策略模式解决鸭子问题"><a href="#3-策略模式解决鸭子问题" class="headerlink" title="3.策略模式解决鸭子问题"></a>3.策略模式解决鸭子问题</h3><p><strong>策略模式解决鸭子问题的分析</strong></p>
<p>1）设计方案</p>
<p>需要新的设计方式，应对项目的扩展性，降低复杂度：<br>a.   分析项目变化与不变部分，提取变化部分，抽象成接口+实现；(抽象是共性，接口是特性)<br>b.   鸭子那些功能是会根据新需求变化的？叫声、飞行<br>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyBehavior&#123;</span><br><span class="line">void fly();</span><br><span class="line">&#125;</span><br><span class="line">public interface QuackBehavior&#123;</span><br><span class="line">void quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.   好处：新增行为简单，行为类更好的复用，组合方便。既有继承带来的复用好处，没有挖坑</p>
<p>2)代码实现</p>
<p><strong>.java文件说明：</strong><br>Duck.java:基类鸭子<br>GreenHeadDuck.java:绿头鸭<br>RedHeadDuck.java:红头鸭<br>SimulateDuck.java:模拟鸭子（main）<br>FlyBehavior.java:（接口）特有的飞行行为<br>QuackBehavior.java:(接口)特有的叫喊行为<br>BadFlyBehavior.java:飞行行为的实现类<br>BadQuackBehavio.java:叫喊行为的实现类</p>
<p>Duck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象类：鸭子</span><br><span class="line">public  abstract class Duck &#123;</span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        &#x2F;&#x2F;子类的构造函数中可以定义行为</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中已经实现了</span><br><span class="line">    public void quack()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;~~嘎嘎叫~~&quot;);</span><br><span class="line">        quackBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由子类实现</span><br><span class="line">    public abstract void display();</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中自己已经实现了</span><br><span class="line">    public void swim()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;~~我会游泳~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实例化对象时可以动态的改变对象的行为(比继承灵活性强)</span><br><span class="line">    public void SetFlyBehavior(FlyBehavior fb) &#123;</span><br><span class="line"></span><br><span class="line">        flyBehavior &#x3D; fb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;实例化对象时可以动态的改变对象的行为</span><br><span class="line">    public void SetQuackBehavior(QuackBehavior qb) &#123;</span><br><span class="line">        quackBehavior &#x3D; qb;</span><br><span class="line">    &#125;</span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;飞&quot;);</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>GreenHeadDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GreenHeadDuck extends Duck &#123;</span><br><span class="line">    public GreenHeadDuck()&#123;</span><br><span class="line">        &#x2F;&#x2F;行为轴展示具体的行为</span><br><span class="line">        flyBehavior &#x3D; new BadFlyBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我和你们不一样，我的头是绿色的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;覆盖超类</span><br><span class="line">&#x2F;&#x2F;    public void fly()&#123;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;我不会飞&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RedHeadDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RedHeadDuck extends Duck &#123;</span><br><span class="line">    public RedHeadDuck()&#123;</span><br><span class="line">        quackBehavior &#x3D; new BadQuackBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我是独一无二的,我的头是红色的&quot;);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>SimulateDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主类：模拟鸭子</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SimulateDuck &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;父类为Duck,屏蔽了超类的差别性</span><br><span class="line">       Duck greenHeadDuck &#x3D; new GreenHeadDuck();</span><br><span class="line">        Duck redHeadDuck&#x3D;new RedHeadDuck();</span><br><span class="line">&#x2F;&#x2F;        GreenHeadDuck greenHeadDuck &#x3D; new GreenHeadDuck();</span><br><span class="line">&#x2F;&#x2F;        RedHeadDuck redHeadDuck &#x3D; new RedHeadDuck();</span><br><span class="line">        greenHeadDuck.display();</span><br><span class="line">        greenHeadDuck.fly();</span><br><span class="line">        greenHeadDuck.SetQuackBehavior(new QuackBehavior() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void quack() &#123;</span><br><span class="line">                System.out.println(&quot;我会叫&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">        redHeadDuck.display();</span><br><span class="line">        redHeadDuck.quack();</span><br><span class="line">        redHeadDuck.swim();</span><br><span class="line">        redHeadDuck.SetFlyBehavior(new FlyBehavior() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void fly() &#123;</span><br><span class="line">                System.out.println(&quot;我会飞&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FlyBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyBehavior &#123;</span><br><span class="line">    void fly();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>QuackBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface QuackBehavior &#123;</span><br><span class="line">    void quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BadFlyBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BadFlyBehavior implements FlyBehavior&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;我不会飞&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BadQuackBehavio.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BadQuackBehavior  implements QuackBehavior&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void quack() &#123;</span><br><span class="line">        System.out.println(&quot;我不会叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：运用设计模式中的策略模式，把变化的部分提取出来变为接口+实现。</strong></p>
<p><strong>Duck类中的SetQuackBehavoir()方法，灵活的让实例化对象灵活的改变对象的行为。比如，绿头鸭，使用了SetQuackBehavoir（）方法，定制了自己的quck()方法。因为不是每只鸭都能叫的。叫的是当前鸭的特性。</strong></p>
<h3 id="4-设计原则"><a href="#4-设计原则" class="headerlink" title="4.设计原则"></a>4.设计原则</h3><p>策略模式体现了几个<strong>设计原则</strong></p>
<ul>
<li><p>封装变化：把变化的代码从不变的代码中分离出来（找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起。）</p>
</li>
<li><p>针对接口编程而不是具体类（定义了策略接口）</p>
</li>
<li><p>多用组合/聚合，少用继承（客户通过组合方式使用策略）</p>
</li>
</ul>
<h3 id="5-价格计算问题"><a href="#5-价格计算问题" class="headerlink" title="5.价格计算问题"></a>5.价格计算问题</h3><p>以一个价格计算策略为背景</p>
<p><strong>没有用策略模式</strong></p>
<p>我们一般是下面的写法,直接写一个类,在类里面直接写策略算法(功能实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class NoStrategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 传入客服等级类型获取相应的价格</span><br><span class="line">     * @param type   会员类型(等级)</span><br><span class="line">     * @param price  响应的价格</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public double getPrice(String type, double price) &#123;</span><br><span class="line"></span><br><span class="line">        if (&quot;普通客户小批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 不打折,原价&quot;);</span><br><span class="line">            return price;</span><br><span class="line">        &#125; else if (&quot;普通客户大批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打九折&quot;);</span><br><span class="line">            return price * 0.9;</span><br><span class="line">        &#125; else if (&quot;老客户小批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打八折&quot;);</span><br><span class="line">            return price * 0.8;</span><br><span class="line">        &#125; else if (&quot;老客户大批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打七折&quot;);</span><br><span class="line">            return price * 0.7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;拓展一种策略</span><br><span class="line">   &#x2F;&#x2F;     &#125;else if(&quot;老客户特大批量&quot;.equals(type))&#123;</span><br><span class="line">   &#x2F;&#x2F;        System.out.println(&quot;[未采用设计模式] 打六折&quot;);</span><br><span class="line">   &#x2F;&#x2F;         return price*0.6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;乱传的也是当普通客户小批量(就是不打折)</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NoStrategy:没有策略的做法</li>
<li>实现起来比较容易，符合一般开发人员的思路</li>
<li>假如，类型特别多，算法比较复杂时，整个条件语句的代码就变得很长，难于维护。</li>
<li>如果有新增类型，就需要频繁的修改此处的代码！</li>
<li>不符合开闭原则！—对这个类的修改要关闭,就是这个类要是写好了就不要去改他了,对类的功能的拓展要开放,显然只有面向接口编程才满足,</li>
<li>所以应用策略模式Strategy这个接口</li>
</ul>
<h3 id="6-策略模式解决价格计算问题"><a href="#6-策略模式解决价格计算问题" class="headerlink" title="6.策略模式解决价格计算问题"></a>6.策略模式解决价格计算问题</h3><p>1.写一个策略接口Strategy</p>
<ul>
<li>Strategy:策略接口</li>
<li>这个是对类NoStrategy改成面向接口的方式实现策略,不像NoStrategy一样,直接写死策略的实现,而是使用这个接口先定义策略</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过策略获取价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    double getPrice(double standardPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.面向接口,组合编程,少用继承(继承虽然可以复用代码,但是会造成耦合度增加,解决方式往往采用接口做类的属性),如下,这样所有实现Strategy 的各种策略实现类都”组合”到这个类里面了</p>
<ul>
<li>Context:策略模式上下文—策略接收器,专门接收策略实现的算法</li>
<li>负责和具体的策略类交互</li>
<li>这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。</li>
<li>如果使用spring的依赖注入功能，还可以通过配置文件，动态的注入不同策略对象，动态的切换不同的算法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前采用的算法对象</span><br><span class="line">     * 面向接口,组合编程,少用继承</span><br><span class="line">     * 简言之复杂类型(类,接口等)做属性</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public Context(Strategy strategy) &#123;</span><br><span class="line"></span><br><span class="line">        this.strategy &#x3D; strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getReultPrice(double price)&#123;</span><br><span class="line"></span><br><span class="line">        return this.strategy.getPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3:既然是策略模式接口Strategy都明确了要做的事情是根据会员情况,返回价格,但是没有真正的实现,那么总有类来实现赛</p>
<p>策略实现类1  VIP0Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP0Strategy:普通会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP0Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP0Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]普通会员 原价:&quot;+standardPrice);</span><br><span class="line">        return standardPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类2  VIP1Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP1Strategy: 一级会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP1Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP1Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]一级会员 打九折：&quot;+standardPrice * 0.9);</span><br><span class="line">        return standardPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类3  VIP2Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP2Strategy:二级会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP2Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP2Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]二级会员八折:&quot;+standardPrice*0.8);</span><br><span class="line">        return standardPrice*0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类4 VIP3Strategy(新增加的需求) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class VIP3Strategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]老客户特大批量:&quot;+standardPrice*0.6);</span><br><span class="line">        return standardPrice*0.6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>4.客户端：</p>
<ul>
<li>Client:策略模式客户端—Client 的main方法 可以想象成我们在使用别人写好的框架,我们有新的需求,对框架开发者来说就是需要对已有的</li>
<li>代码进行维护升级,比如此时我们修改NoStrategy类,那么修改完后新版本的框架NoStrategy类很有能是对已经在使用的客户机制上不兼容的,如果用户升级为新版框架,遇到使用NoStrategy类的会报错,各种不兼容就不符合开发者维护的版本的规范,所以修改已有的类是极其不科学的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import com.cx.price.NoStrategy;</span><br><span class="line">import com.cx.price.VIP1Strategy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;未使用模式-----------------------------------------&quot;);</span><br><span class="line">        NoStrategy noStrategy &#x3D; new NoStrategy();</span><br><span class="line">        double price &#x3D; noStrategy.getPrice(&quot;普通客户大批量&quot;, 1000);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">        System.out.println(&quot;\n测试策略------------------------------------------&quot;);</span><br><span class="line">        Context context0 &#x3D; new Context(new VIP1Strategy());</span><br><span class="line">        double resultPrice &#x3D; context0.getReultPrice(1000);</span><br><span class="line">        System.out.println(resultPrice);</span><br><span class="line">&#x2F;&#x2F;怎么体现策略模式呢?比如现在需求是增加一种会员机制,  &#39;老客户特大批量&#39; ，那么显然打折力度更大,我们设置为6折,</span><br><span class="line">&#x2F;&#x2F; 分别在未使用策略模式和使用了策略模式的基础上拓展,看那个更加易于拓展,方便维护</span><br><span class="line">        &#x2F;&#x2F;为了实现这么一个折扣计算功能，代码需要写4个if-else，如果需求再增多一个规则，代码还需重构if-else，这样在可维护性、可读性大大降低，而且修改容易出bug。</span><br><span class="line">        &#x2F;&#x2F;如果运用策略模式，每个规则对应一个策略，根据符合的条件对应选择哪一种策略，这样整体代码逻辑清晰，而且不管新增或修改规则时，只需要新增或调整对应的规则策略，这样大大降低bug的风险，可维护性更高。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;新增策略后未使用模式(会修该策略核心类)</span><br><span class="line">&#x2F;&#x2F;        NoStrategy noStrategy1 &#x3D; new NoStrategy();</span><br><span class="line">&#x2F;&#x2F;        double price1 &#x3D; noStrategy1.getPrice(&quot;老客户特大批量&quot;, 1000);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(price1);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;新增策略后使用模式(不会修改策略接口,只是添加一个实现)</span><br><span class="line">&#x2F;&#x2F;        Context context2 &#x3D; new Context(new VIP3Strategy());</span><br><span class="line">&#x2F;&#x2F;        double price2 &#x3D; context2.getReultPrice(1000);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(price2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结论：   修改服务器端已经写好了的类是极其不好的维护形式,因为这个类NoStrategy可能在别的类中作为依赖或者叫做别的类引用了该类,在不明确的情况下,可能牵一发动全身,是不好的维护方式,使用了策略模式，我们只是添加了一个策略接口的实现,低侵入式,不会对已有代码造成影响,低耦合</p>
<h3 id="7-策略模式原理类图"><a href="#7-策略模式原理类图" class="headerlink" title="7.策略模式原理类图"></a>7.策略模式原理类图</h3><p>说明：从上面这个图可以看出来客户context有成员变量strategy或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定</p>
<p>策略模式的主要角色如下：</p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<h3 id="8-策略模式的总结"><a href="#8-策略模式的总结" class="headerlink" title="8.策略模式的总结"></a>8.策略模式的总结</h3><p>1）策略模式的关键是 ：<strong>分析项目中变化部分与不变部分</strong><br>2）策略模式的核心思想是 ：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性。<br>3）体现了“开闭原则”(对修改关闭，对扩展开放)。客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if…else if … else)；<br>4）提供了可以替换继承关心的办法 ：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。<br>5）需要注意的是 ：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" data-id="ckjcfcev500012oul0q5gdy8t" data-title="策略模式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          冒泡排序
        
      </div>
    </a>
  
  
    <a href="/2020/12/31/hello-world1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/06/%E7%BF%BB%E8%AF%91/">翻译</a>
          </li>
        
          <li>
            <a href="/2021/01/06/%E7%90%86%E8%A7%A3/">对Okta的相关理解</a>
          </li>
        
          <li>
            <a href="/2021/01/01/github%20pages/">GitHub Pages搭建博客详解</a>
          </li>
        
          <li>
            <a href="/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
          </li>
        
          <li>
            <a href="/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>