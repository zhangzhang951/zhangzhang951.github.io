<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>张心蕊的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="不积跬步，无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="张心蕊的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="张心蕊的博客">
<meta property="og:description" content="不积跬步，无以至千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张心蕊的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张心蕊的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-翻译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/06/%E7%BF%BB%E8%AF%91/" class="article-date">
  <time class="dt-published" datetime="2021-01-06T14:19:56.423Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/06/%E7%BF%BB%E8%AF%91/">翻译</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Authentication-API-VS-OAuth-2-0-VS-OpenID-Connect"><a href="#Authentication-API-VS-OAuth-2-0-VS-OpenID-Connect" class="headerlink" title="Authentication API VS OAuth 2.0 VS OpenID Connect"></a>Authentication API VS OAuth 2.0 VS OpenID Connect</h2><p>Okta可以执行三种主要的身份验证：</p>
<ul>
<li>该认证API控制访问你的组织和应用。它提供了操作来验证用户身份，执行多因素注册和验证，恢复忘记的密码以及解锁帐户。Okta登录小部件和Auth JS都是在后台使用的基础API。</li>
<li>OAuth 2.0协议控制授权访问受保护的资源，像你的Web应用程序，本地应用，或API服务。</li>
<li>该ID连接协议是建立在OAuth 2.0通讯协定，并帮助用户进行身份验证，并传达他们的信息。例如，在范围定义上，它比普通的OAuth 2.0更有想法。</li>
</ul>
<p>如果您想使用Okta API并控制用户对Okta的访问，则应该使用Authentication API</p>
<p>如果您有兴趣控制对自己应用程序的访问，请使用OAuth 2.0和OpenID Connect协议。OAuth 2.0协议通过作用域访问令牌提供API安全性。OAuth 2.0使您可以委派授权，而OpenID Connect协议使您可以检索和存储有关最终用户的身份验证信息。OpenID Connect通过提供用户身份验证和单点登录（SSO）功能扩展了OAuth 2.0。</p>
<h3 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h3><p>OAuth 2.0是应用程序用来向客户端应用程序提供访问权限的标准。如果您想以安全的方式授予对您的应用程序数据的访问权限，那么您想使用OAuth 2.0协议。</p>
<p>OAuth 2.0规范具有四个重要角色：</p>
<ul>
<li>“授权服务器” —颁发访问令牌的服务器。在这种情况下，Okta是授权服务器。</li>
<li>“资源所有者”-通常是您的应用程序的最终用户，该用户授予使用访问令牌访问资源服务器的权限</li>
<li>“客户端” —从Okta请求访问令牌，然后将其传递到资源服务器的应用程序</li>
<li>“资源服务器” —接受访问令牌，并且必须验证其是否有效。在这种情况下，这就是您的应用程序。</li>
</ul>
<p>其他重要条件：</p>
<ul>
<li>OAuth 2.0“授予”是用户授予（或“授予”）客户端的授权。授予的示例是“授权码”和“客户端凭据”。每个OAuth授权都有相应的流程，如下所述。</li>
<li>授权服务器（Okta）发行“访问令牌”以换取授予。</li>
<li>“刷新令牌”是可选令牌，如果访问令牌已过期，则该令牌将交换为新的访问令牌。</li>
</ul>
<p>通常的OAuth 2.0授予流程如下所示：</p>
<ol>
<li>客户端向资源所有者（通常是用户）请求授权。</li>
<li>如果用户提供授权，则客户端将授权授予传递给授权服务器（在本例中为Okta）。</li>
<li>如果授权有效，则授权服务器将返回访问令牌，可能还附带刷新和/或ID令牌。</li>
<li>客户端现在使用该访问令牌来访问资源服务器。</li>
</ol>
<p>授权服务器是OAuth 2.0及其OpenID Connect扩展的核心。授权服务器只是OAuth 2.0令牌生成引擎。每个授权服务器都有一个唯一的发行者URI和自己的令牌签名密钥，以在安全域之间保持适当的边界。在本指南中，Okta是您的授权服务器。</p>
<p>授权服务器还充当OpenID Connect Provider，这意味着除了从授权服务器端点访问令牌外，您还可以请求ID令牌。</p>
<h3 id="OpenID连接"><a href="#OpenID连接" class="headerlink" title="OpenID连接"></a>OpenID连接</h3><p>OpenID Connect是建立在OAuth 2.0之上的身份验证标准。它添加了一个额外的令牌，称为ID令牌。OpenID Connect还可以标准化OAuth 2.0可以选择的区域，例如范围，端点发现和客户端动态注册。Okta已通过OpenID认证。</p>
<p>尽管OpenID Connect建立在OAuth 2.0之上，但OpenID Connect规范对流中的角色使用了稍有不同的术语：</p>
<ul>
<li>“ OpenID提供程序”-颁发ID令牌的授权服务器。在这种情况下，Okta是OpenID提供程序。</li>
<li>“最终用户”-其信息包含在ID令牌中</li>
<li>“依赖方” —向Okta请求ID令牌的客户端应用程序</li>
<li>“ ID令牌”由OpenID提供商发布，并以声明的形式包含有关最终用户的信息。</li>
<li>“声明”是有关最终用户的一条信息。</li>
</ul>
<p>对于OpenID Connect和常规OAuth 2.0流，高级流看起来相同。主要区别在于，除了任何访问或刷新令牌之外，OpenID Connect流程还会生成一个ID令牌。</p>
<h2 id="选择OAuth-2-0流程"><a href="#选择OAuth-2-0流程" class="headerlink" title="选择OAuth 2.0流程"></a>选择OAuth 2.0流程</h2><p>您使用哪种OAuth流程取决于您的用例。下表将应用程序类型映射到我们建议的OAuth 2.0流。如果您需要更多信息，请继续阅读以下内容以寻求帮助，以根据（1）您所需的令牌类型和/或（2）您正在构建的客户端应用程序的类型来选择OAuth流。</p>
<h3 id="按应用程序类型推荐的流量"><a href="#按应用程序类型推荐的流量" class="headerlink" title="按应用程序类型推荐的流量"></a>按应用程序类型推荐的流量</h3><p>下表显示了要用于正在构建的应用程序类型的OAuth 2.0流。</p>
<table>
<thead>
<tr>
<th align="left">申请类型</th>
<th align="left">OAuth 2.0流程</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务器端（AKA Web）</td>
<td align="left">授权码流程</td>
</tr>
<tr>
<td align="left">单页应用</td>
<td align="left">当要构建的SPA在不支持PKCE的Web加密的较旧的浏览器中运行时，带有PKCE隐式流程的授权代码流</td>
</tr>
<tr>
<td align="left">本机</td>
<td align="left">PKCE的授权码流</td>
</tr>
<tr>
<td align="left">值得信赖</td>
<td align="left">资源所有者密码流</td>
</tr>
<tr>
<td align="left">服务</td>
<td align="left">客户凭证</td>
</tr>
</tbody></table>
<h3 id="您的应用程序需要ID令牌吗？"><a href="#您的应用程序需要ID令牌吗？" class="headerlink" title="您的应用程序需要ID令牌吗？"></a>您的应用程序需要ID令牌吗？</h3><p>任何OAuth流都可以为您提供访问令牌，但并非全部都支持ID令牌。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="center">访问令牌</th>
<th align="center">ID令牌</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>授权码</strong></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="left"><strong>PKCE的授权码</strong></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="left"><strong>隐含的</strong></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="left"><strong>资源所有者密码</strong></td>
<td align="center">✅</td>
<td align="center">✅</td>
</tr>
<tr>
<td align="left"><strong>客户凭证</strong></td>
<td align="center">✅</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<h3 id="您要建立什么样的客户？"><a href="#您要建立什么样的客户？" class="headerlink" title="您要建立什么样的客户？"></a>您要建立什么样的客户？</h3><p>OAuth 2.0流的类型取决于您要构建的客户端类型。此流程图可以帮助您快速确定要使用的流程。</p>
<p><img src="https://developer.okta.com/img/oauth_grant_flowchart.png" alt="OAuth流程图宽度："></p>
<h4 id="您的客户公开吗？"><a href="#您的客户公开吗？" class="headerlink" title="您的客户公开吗？"></a>您的客户公开吗？</h4><p>当最终用户可以查看和修改代码时，将客户端应用程序视为公共应用程序。这包括单页应用程序（SPA）或任何移动或本机应用程序。在这两种情况下，应用程序都无法保留恶意用户的机密。</p>
<h4 id="您的客户是SPA还是本机？"><a href="#您的客户是SPA还是本机？" class="headerlink" title="您的客户是SPA还是本机？"></a>您的客户是SPA还是本机？</h4><p>如果您的客户端应用程序是在支持Web Crypto for PKCE的现代浏览器中运行的SPA，则应使用PKCE的授权码流。如果您的客户端应用程序是可在不支持PKCE的Web加密的较旧浏览器中运行的SPA，则应使用Implicit flow。因为隐式流适用于无法保证客户端机密性的应用程序，所以仅在其他流不可行的情况下才应使用此流。</p>
<p>如果您的客户端应用程序是本机应用程序，则应使用带有PKCE的授权代码流。</p>
<h4 id="客户是否有最终用户？"><a href="#客户是否有最终用户？" class="headerlink" title="客户是否有最终用户？"></a>客户是否有最终用户？</h4><p>如果您的客户端应用程序在没有直接最终用户的服务器上运行，则可以信任它存储凭据并负责任地使用它们。如果您的客户端应用程序仅在计算机之间进行交互，则应使用“客户端凭据”流程。</p>
<h4 id="资源所有者是否拥有客户端？"><a href="#资源所有者是否拥有客户端？" class="headerlink" title="资源所有者是否拥有客户端？"></a>资源所有者是否拥有客户端？</h4><p>如果您同时拥有客户端应用程序和所访问的资源，则可以信任您的应用程序来存储最终用户的用户名和密码。由于此处要求高度信任，因此仅在其他流程不可行时才应使用“资源所有者密码”流程。</p>
<h3 id="授权码流程"><a href="#授权码流程" class="headerlink" title="授权码流程"></a>授权码流程</h3><p>授权代码流最适合未公开公开源代码的服务器端应用程序。这些应用程序应该是服务器端的，因为交换令牌的授权代码的请求需要一个客户端密钥，该密钥必须存储在客户端中。但是，服务器端应用程序需要最终用户，因为它依赖于与最终用户Web浏览器的交互，该浏览器将重定向用户，然后接收授权码。</p>
<p><img src="https://developer.okta.com/img/oauth_auth_code_flow.png" alt="验证码流宽度："></p>
<h3 id="PKCE的授权码流"><a href="#PKCE的授权码流" class="headerlink" title="PKCE的授权码流"></a>PKCE的授权码流</h3><p>对于网络/本机/移动应用程序，客户端机密无法存储在应用程序中，因为它很容易被公开。此外，移动重定向使用<code>app://</code>易于拦截的协议。基本上，流氓应用程序可以在通过移动/本机操作系统传递授权代码时对其进行拦截。因此，本机应用程序应使用代码交换证明密钥（PKCE），以确保授权码流的安全，该密钥像机密但未进行硬编码。</p>
<p>PKCE是常规授权码流程的扩展，因此该流程非常相似，只是在流程的各个步骤中都包含PKCE元素。</p>
<blockquote>
<p><strong>注意：</strong>带有PKCE的授权代码流不支持SPA和其他基于浏览器的应用程序的刷新令牌。</p>
</blockquote>
<p>PKCE增强的授权代码流要求您的应用程序生成一个称为“代码验证程序”的加密随机密钥。然后，从验证程序创建一个“代码质询”，并将此质询与授权码请求一起传递。</p>
<p>在访问令牌请求中发送了授权代码后，代码验证程序将作为请求的一部分发送。授权服务器使用约定的哈希算法重新计算来自验证程序的质询，然后进行比较。如果两个代码质询和验证程序匹配，则它知道两个请求都是由同一客户端发送的。</p>
<p>流氓应用程序只能截获授权代码，但无法访问代码质询或验证程序，因为它们都是通过HTTPS发送的。</p>
<p><img src="https://developer.okta.com/img/oauth_auth_code_flow_pkce.png" alt="具有PKCE宽度的身份验证代码流："></p>
<h3 id="隐式流"><a href="#隐式流" class="headerlink" title="隐式流"></a>隐式流</h3><p>隐式流适用于无法保证客户端机密性的应用程序。在此流程中，客户端不向<code>/token</code>端点发出请求，而是直接从<code>/authorize</code>端点接收访问令牌。客户端必须能够与资源所有者的用户代理进行交互，还必须能够接收来自授权服务器的请求（通过重定向）。</p>
<blockquote>
<p><strong>注意：</strong>因为隐式流是针对不太信任的客户端的，所以它不支持刷新令牌。</p>
</blockquote>
<blockquote>
<p><strong>重要说明：</strong>对于在支持PKCE的Web Crypto的现代浏览器中运行的单页应用程序（SPA），建议使用带有PKCE的授权码流而不是隐式流，以实现最大的安全性。如果需要支持较旧的浏览器，则隐式流程提供了一个可行的解决方案。</p>
</blockquote>
<p><img src="https://developer.okta.com/img/oauth_implicit_flow.png" alt="隐式流宽度："></p>
<h3 id="资源所有者密码流"><a href="#资源所有者密码流" class="headerlink" title="资源所有者密码流"></a>资源所有者密码流</h3><p>资源所有者密码流适用于您同时控制客户端应用程序和与其交互的资源的用例。它要求客户端可以存储客户端机密，并且资源所有者的凭据可以信任客户端，因此，在用于在线服务的客户端（例如与Facebook服务交互的Facebook客户端应用程序）中最常见。它不需要像授权码或隐式流这样的重定向，并且涉及到<code>/token</code>端点的单个经过身份验证的调用。</p>
<p><img src="https://developer.okta.com/img/oauth_password_flow.png" alt="资源所有者密码流宽度："></p>
<h3 id="客户凭证流"><a href="#客户凭证流" class="headerlink" title="客户凭证流"></a>客户凭证流</h3><p>客户端凭据流适用于没有最终用户的服务器端（AKA“机密”）客户端应用程序，该应用程序通常描述机器对机器的通信。该应用程序必须在服务器端，因为它必须受到客户端机密的信任，并且由于凭据是经过硬编码的，因此实际的最终用户不能使用它。它涉及到<code>/token</code>端点的单个经过身份验证的请求，该请求返回访问令牌。</p>
<blockquote>
<p><strong>注意：</strong> “客户端凭据流”不支持刷新令牌。</p>
</blockquote>
<p><img src="https://developer.okta.com/img/oauth_client_creds_flow.png" alt="客户端凭据流宽度："></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/06/%E7%BF%BB%E8%AF%91/" data-id="ckjliiiv100012gulguar6zvc" data-title="翻译" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/06/%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2021-01-06T14:19:48.272Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/06/%E7%90%86%E8%A7%A3/">对Okta的相关理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对于Okta来说，想使用Okta API并控制用户对Okta的访问，需要使用到Authentication API。WEB API 使用这项API进行验证的时AuthenticationFilter列表，如果有多个则通过FilterScope来进行排序，最终形成AuthenticationFilter管道。</p>
<p>在对自己应用程序的访问进行控制时，使用OAuth 2.0和OpenID Connect协议，OAuth 2.0协议是通过作用域访问令牌提供API安全性。OpenID Connect协议使我们可以检索和存储身份验证信息。OpenID Connect 通过提供身份验证和SSO拓展了OAuth 2.0.</p>
<p>OAuth 2.0规范有四个角色：授权服务器、资源所有者、客户端、资源服务器，OAuth 2.0是给用户授予客户端的授权，每个OAuth授权都有对应的流程：首先是客户端向用户请求授权，如果用户进行提供，则授权授予给Okta，在授权有效的前提下，授权服务器返回访问令牌，附带刷新和ID令牌，客户端使用访问令牌访问用户。</p>
<p>授权服务器是OAuth 2.0和OpenID Connect扩展的核心，每个都会有自己唯一一个发行和URI和令牌签名秘钥。授权服务器通过Web应用进行身份验证，并且获取用户的配置文件信息。不可以在不同的授权服务器之间混合令牌，在设计中，授权服务器之间是没有信任关系的。Okta有两种授权服务器，是组织授权服务器和自定义授权服务器。</p>
<p>组织授权服务器，Okta的每个组织都有一个称为Org Authorization Server的内置授权服务器。可以使用组织授权服务器对OpenID Connect应用程序的Okta执行SSO，或者获取Okta API的访问令牌。</p>
<p>自定义授权服务器可以用来创建和应用授权策略保护自己的API，API占用了自定义授权服务器铸造的访问令牌。Okta允许在单个Okta组织中创建多个自定义授权服务器，用来保护自己的资源服务器。在每一个授权服务器中，可以自定义OAuth 2.0范围、声明、访问策略以支持对API的授权。</p>
<p>在选用授权服务器的时候，我们应该如何对授权服务器进行选择，如果是想基于OpenID Connect的应用程序添加SSO，或者要在Okta API中使用OAuth 2.0承载令牌，则可以使用组织授权服务器。只有组织服务器才能包括Okta API范围的访问令牌。如果应用程序具有其它范围，在何时授予范围等需求时，应该自己创建一个Custom Authorization Server。    </p>
<p>OpenID Connect是建立在OAuth 2.0之上的身份验证标准，他增加了一个额外的令牌，叫ID令牌，他还可以标准化OAuth 2.0可以选择的区域，他使用了一些不同于原先的术语。在OpenID Connect和OAuth 2.0流中，高级流看起来相同，主要区别是在于OpenID Connect流程生成了一个ID令牌。</p>
<p>对于我们选择OAuth 2.0流程是取决于我们的应用程序，根据不同的需求对流程的不同要求进行选择。对于授权码流，最适合未公开源代码的应用程序，因为密钥必须储存在客户端中，所以服务器端应用程序需要最终用户。因为它十分依赖于最终用户和Web浏览器的交互，所以要重定向用户，然后接收授权。PKCE的授权码流是对于移动应用程序，客户端无法储存密钥在应用程序中。<br>因为移动应用程序很容易被公开，所以我们可以通过操作在系统传递授权代码时，对其进行拦截。因此，我们为了确保代码流的安全性，就需要使用代码交换证明PKCE。也就是使用随机加密对代码进行加密，在验证程序中创建一个“代码质询”，并将质询与授权码请求一起传递过去。隐式流相对于一些不需保证客户端机密性的应用程序非常适用。在这个流程中，客户端不向token断电<br>发出请求，而是从authorize端点接收访问令牌，所以客户端必须与资源所有者的用户代理进行交互。隐式流是真对一些不信任客户端的应用程序，所以把它并不支持刷新令牌。资源所有者密码流可以用于同时控制客户端应用程序和与其交互的资源的用例。他要求客户端存储客户机密，并且资源所有者的凭据可以信任客户端。例如现在的FaceBook服务交互的FaceBook客户端应用<br>程序就是最常见的在线服务的客户端，他并不需要重定向，也不需要token端点的身份验证的调用。客户端凭据流是适用于没有最终用户的AKA客户端应用程序。该应用程序必须在服务器端，所以他必须收到客户端AKA的信任。凭据是经过硬编码，最终用户不能使用，在涉及到token身份验证的请求时，直接返回访问令牌。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/06/%E7%90%86%E8%A7%A3/" data-id="ckjliiiun00002gul8qzigtmc" data-title="对Okta的相关理解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-github pages" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/01/github%20pages/" class="article-date">
  <time class="dt-published" datetime="2021-01-01T13:33:39.441Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/01/github%20pages/">GitHub Pages搭建博客详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="一、创建一个仓库："><a href="#一、创建一个仓库：" class="headerlink" title="一、创建一个仓库："></a>一、创建一个仓库：</h4><p>转到<a target="_blank" rel="noopener" href="https://github.com/">GitHub</a>并<a target="_blank" rel="noopener" href="https://github.com/new">创建一个</a>名为<em>username</em> .github.io<a target="_blank" rel="noopener" href="https://github.com/new">的新存储库</a>，其中<em>username</em>是您在GitHub上的用户名（或组织名称）,如图所示。<br><a target="_blank" rel="noopener" href="https://zhangzhang951.github.io/images/image-20210101195609788.png">https://zhangzhang951.github.io/images/image-20210101195609788.png</a></p>
<h4 id="二、克隆存储库到存储项目的文件夹"><a href="#二、克隆存储库到存储项目的文件夹" class="headerlink" title="二、克隆存储库到存储项目的文件夹"></a>二、克隆存储库到存储项目的文件夹</h4><p><strong>方式一：</strong></p>
<ol>
<li>可以下载一个giuhub桌面<br><a target="_blank" rel="noopener" href="https://zhangzhang951.github.io/images/%E4%B8%8B%E8%BD%BDgithub%E6%A1%8C%E9%9D%A2.PNG">https://zhangzhang951.github.io/images/下载github桌面.PNG</a></li>
</ol>
<p>   注：这里我建立博客仓库时，命名错误，库名要和github的用户名保持一致，不然访问博客的域名就会变得特别繁琐，可以在GitHub–&gt;Settings–&gt;Options–&gt;Repository name更改库名</p>
<ol start="2">
<li>点击Set up in Desktop克隆存储库，完成安装后，返回GitHub.com并刷新页面。单击“在桌面上设置”按钮。当GitHub桌面应用程序打开时，保存项目。</li>
</ol>
<p><strong>方式二：</strong></p>
<p>转到要存储项目的文件夹，然后克隆新的存储库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ git clone 存储库的地址</span><br></pre></td></tr></table></figure>
<h4 id="三、进入项目文件夹并添加index-html文件，然后推送到github上"><a href="#三、进入项目文件夹并添加index-html文件，然后推送到github上" class="headerlink" title="三、进入项目文件夹并添加index.html文件，然后推送到github上"></a><strong>三、进入项目文件夹并添加index.html文件，然后推送到github上</strong></h4><p>这时候我们就可以访问博客了，但是这时候只有特别简单的一个页面，并不美观（这里推送到github我用的是sourcetree）</p>
<h3 id="如何使博客变得美观"><a href="#如何使博客变得美观" class="headerlink" title="如何使博客变得美观"></a>如何使博客变得美观</h3><p>我开始并不了解博客工具，所以我去搜索了一下，我的博客使用了<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a>生成工具。</p>
<p>（GitHub官方建议使用博客生成工具 <a target="_blank" rel="noopener" href="https://help.github.com/articles/using-jekyll-as-a-static-site-generator-with-github-pages/">Jekyll</a> 。GitHub在库的设置里面还提供Jekyll主题选择。）</p>
<h4 id="一、-安装环境"><a href="#一、-安装环境" class="headerlink" title="一、 安装环境"></a><strong>一、 安装环境</strong></h4><p>安装Hexo之前，需要准备node和git环境</p>
<ol>
<li><p>安装NodeJs,因为Hexo是基于Node.js驱动的一款博客框架</p>
</li>
<li><p>安装git,最好是安装最新的版本<br><a target="_blank" rel="noopener" href="https://zhangzhang951.github.io/images/image-20210101210601655.png">https://zhangzhang951.github.io/images/image-20210101210601655.png</a></p>
</li>
</ol>
<p>这里我参考了<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/">Hexo</a>的详细文档</p>
<h4 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a><strong>二、安装Hexo</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>在_config.yml文件里可以更改博客标题等</p>
<h3 id="将Hexo部署到GitHub-Pages"><a href="#将Hexo部署到GitHub-Pages" class="headerlink" title="将Hexo部署到GitHub Pages"></a>将Hexo部署到GitHub Pages</h3><h4 id="一、用idea打开myblog"><a href="#一、用idea打开myblog" class="headerlink" title="一、用idea打开myblog"></a><strong>一、用idea打开myblog</strong></h4><p><a target="_blank" rel="noopener" href="https://zhangzhang951.github.io/images/image-20210101212402279.png">https://zhangzhang951.github.io/images/image-20210101212402279.png</a></p>
<h4 id="二、把你的博客文件（-md格式）复制到source-gt-posts下，运行，build"><a href="#二、把你的博客文件（-md格式）复制到source-gt-posts下，运行，build" class="headerlink" title="二、把你的博客文件（.md格式）复制到source-&gt;_posts下，运行，build"></a><strong>二、把你的博客文件（.md格式）复制到source-&gt;_posts下，运行，build</strong></h4><h4 id="三、将public文件里的所有内容复制到项目文件里，然后推送到github"><a href="#三、将public文件里的所有内容复制到项目文件里，然后推送到github" class="headerlink" title="三、将public文件里的所有内容复制到项目文件里，然后推送到github"></a><strong>三、将public文件里的所有内容复制到项目文件里，然后推送到github</strong></h4><p>以上就是全部内容，这时候我们重新访问博客，就可以看到一个美观的博客啦！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/01/github%20pages/" data-id="ckjebrk0i0000vkuldwm5gc5o" data-title="GitHub Pages搭建博客详解" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-冒泡排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T06:07:58.775Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.xr.array;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">  &#x2F;*</span><br><span class="line">    冒泡排序：两层循环，外层冒泡轮数，里层依次比较</span><br><span class="line">    1.比较数组中两个相邻的元素，如果第一个数比第二个数大，我们就交换她们的位置</span><br><span class="line">    2.每一次比较，都会产生一个最大或者最小的数字</span><br><span class="line">    3.下一轮则可以少一次排序</span><br><span class="line">    4.依次循环，直到结束</span><br><span class="line">     *&#x2F;</span><br><span class="line">public class BubbleSort2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;输入要排序的值，输入的每个值用逗号隔开&quot;);</span><br><span class="line">        Scanner input &#x3D; new Scanner(System.in);</span><br><span class="line">        String str &#x3D; input.nextLine();</span><br><span class="line">        String[] strArray &#x3D; str.split(&quot;,&quot;);</span><br><span class="line">        int[] array &#x3D; new int[strArray.length];</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; strArray.length ; i++)&#123;</span><br><span class="line">            array[i] &#x3D; Integer.parseInt(strArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;排序前的数组&quot;+ Arrays.toString(array));</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(&quot;排序后的数组&quot; + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">  private static void sort(int[] array) &#123;</span><br><span class="line">  &#x2F;&#x2F;临时变量</span><br><span class="line">        int temp &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;外层循环，判断要走多少次</span><br><span class="line">    for (int i &#x3D;0 ;i &lt;array.length-1;i++)&#123;</span><br><span class="line">        System.out.println(&quot;第&quot;+(i+1)+&quot;轮&quot;);</span><br><span class="line">        for (int j &#x3D; 0 ;j&lt; array.length-i-1;j++)&#123;</span><br><span class="line">            &#x2F;&#x2F;内层循环，比较两个数，如果第一个数比第二个数大，交换位置</span><br><span class="line">            if (array[j]&gt;array[j+1])&#123;</span><br><span class="line">                temp &#x3D; array[j];</span><br><span class="line">                array[j] &#x3D; array[j+1];</span><br><span class="line">                array[j+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;第&quot;+(j+1)+&quot;次&quot;+Arrays.toString(array));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/" data-id="ckjcg8w95000050ul9bva8xq6" data-title="冒泡排序" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-策略模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T05:42:05.446Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><pre><code> 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。

 在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。

 如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决这些问题。</code></pre>
<h3 id="1-策略模式的定义与特点"><a href="#1-策略模式的定义与特点" class="headerlink" title="1.策略模式的定义与特点"></a>1.策略模式的定义与特点</h3><p>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p><strong>简述：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。</strong></p>
<p>策略模式的主要优点如下。</p>
<ol>
<li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li>
</ol>
<p>其主要缺点如下。</p>
<ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li>
<li>策略模式造成很多的策略类。</li>
</ol>
<h3 id="2-鸭子问题"><a href="#2-鸭子问题" class="headerlink" title="2.鸭子问题"></a>2.鸭子问题</h3><p><strong>模拟鸭子项目，具体要求如下：</strong></p>
<p>1）有各种鸭子（比如 绿头鸭、红头鸭，鸭子有各种行为，比如叫、游泳）</p>
<p>2）显示鸭子的信息</p>
<p><strong>传统方案解决鸭子问题的分析和代码实现</strong></p>
<p>1）传统的设计方案</p>
<p>2）代码实现</p>
<p><strong>.java文件说明：</strong><br>Duck.java:基类鸭子<br>GreenHeadDuck.java:绿头鸭<br>RedHeadDuck.java:红头鸭<br>SimulateDuck.java:模拟鸭子（main）</p>
<p>Duck.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象类：鸭子</span><br><span class="line">public  abstract class Duck &#123;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        &#x2F;&#x2F;子类的构造函数中可以定义行为</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中已经实现了</span><br><span class="line">    public void quack()&#123;</span><br><span class="line">        System.out.println(&quot;~~嘎嘎叫~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由子类实现</span><br><span class="line">    public abstract void display();</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中自己已经实现了</span><br><span class="line">    public void swim()&#123;</span><br><span class="line">        System.out.println(&quot;~~我会游泳~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>RedHeadDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class RedHeadDuck extends Duck&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我是独一无二的,我的头是红色的&quot;);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GreenHeadDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GreenHeadDuck extends Duck &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我和你们不一样，我的头是绿色的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SimulateDuck.java:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GreenHeadDuck greenHeadDuck&#x3D;new GreenHeadDuck();</span><br><span class="line">   RedHeadDuck redHeadDuck&#x3D;new RedHeadDuck();</span><br><span class="line"></span><br><span class="line">   greenHeadDuck.display();</span><br><span class="line">   greenHeadDuck.quack();</span><br><span class="line">   greenHeadDuck.swim();</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   redHeadDuck.display();</span><br><span class="line">   redHeadDuck.quack();</span><br><span class="line">   redHeadDuck.swim();</span><br></pre></td></tr></table></figure>
<p>我们已经实现了基本的项目需求了。模拟鸭子算是成功啦~！</p>
<p>但是项目添加了<strong>新的需求</strong>，添加会飞的鸭子（并不是所有的鸭子都会飞）</p>
<p><strong>传统的方式实现的问题分析和解决方案</strong></p>
<ul>
<li><p>如果在基类写Fly()方法，其他鸭子，都继承了Duck类，所以fly让所有子类都会飞了，违背逻辑。</p>
</li>
<li><p>这个问题，是继承带来的问题，对类的局部改动，尤其超类的局部改动，会影响其他部分，会有溢出效应</p>
</li>
<li><p>为了改进问题，我们可以通过覆盖fly方法来解决，</p>
</li>
<li><p>问题又来了，如果我们有一个玩具鸭子,这样需要玩具鸭子去覆盖Duck的所有实现的方法 ，覆盖工作量特别大</p>
</li>
<li><p> <em>解决方法：<u>策略模式</u>（strategy pattern）<strong>思路：继承是实现共性，减少代码的重复。接口是实现特性。</strong></em></p>
</li>
</ul>
<h3 id="3-策略模式解决鸭子问题"><a href="#3-策略模式解决鸭子问题" class="headerlink" title="3.策略模式解决鸭子问题"></a>3.策略模式解决鸭子问题</h3><p><strong>策略模式解决鸭子问题的分析</strong></p>
<p>1）设计方案</p>
<p>需要新的设计方式，应对项目的扩展性，降低复杂度：<br>a.   分析项目变化与不变部分，提取变化部分，抽象成接口+实现；(抽象是共性，接口是特性)<br>b.   鸭子那些功能是会根据新需求变化的？叫声、飞行<br>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyBehavior&#123;</span><br><span class="line">void fly();</span><br><span class="line">&#125;</span><br><span class="line">public interface QuackBehavior&#123;</span><br><span class="line">void quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.   好处：新增行为简单，行为类更好的复用，组合方便。既有继承带来的复用好处，没有挖坑</p>
<p>2)代码实现</p>
<p><strong>.java文件说明：</strong><br>Duck.java:基类鸭子<br>GreenHeadDuck.java:绿头鸭<br>RedHeadDuck.java:红头鸭<br>SimulateDuck.java:模拟鸭子（main）<br>FlyBehavior.java:（接口）特有的飞行行为<br>QuackBehavior.java:(接口)特有的叫喊行为<br>BadFlyBehavior.java:飞行行为的实现类<br>BadQuackBehavio.java:叫喊行为的实现类</p>
<p>Duck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象类：鸭子</span><br><span class="line">public  abstract class Duck &#123;</span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    QuackBehavior quackBehavior;</span><br><span class="line"></span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        &#x2F;&#x2F;子类的构造函数中可以定义行为</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中已经实现了</span><br><span class="line">    public void quack()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;~~嘎嘎叫~~&quot;);</span><br><span class="line">        quackBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;由子类实现</span><br><span class="line">    public abstract void display();</span><br><span class="line">    &#x2F;&#x2F;在本抽象类中自己已经实现了</span><br><span class="line">    public void swim()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;~~我会游泳~~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;实例化对象时可以动态的改变对象的行为(比继承灵活性强)</span><br><span class="line">    public void SetFlyBehavior(FlyBehavior fb) &#123;</span><br><span class="line"></span><br><span class="line">        flyBehavior &#x3D; fb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;实例化对象时可以动态的改变对象的行为</span><br><span class="line">    public void SetQuackBehavior(QuackBehavior qb) &#123;</span><br><span class="line">        quackBehavior &#x3D; qb;</span><br><span class="line">    &#125;</span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;飞&quot;);</span><br><span class="line">        flyBehavior.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>GreenHeadDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GreenHeadDuck extends Duck &#123;</span><br><span class="line">    public GreenHeadDuck()&#123;</span><br><span class="line">        &#x2F;&#x2F;行为轴展示具体的行为</span><br><span class="line">        flyBehavior &#x3D; new BadFlyBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我和你们不一样，我的头是绿色的&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;覆盖超类</span><br><span class="line">&#x2F;&#x2F;    public void fly()&#123;</span><br><span class="line">&#x2F;&#x2F;        System.out.println(&quot;我不会飞&quot;);</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RedHeadDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class RedHeadDuck extends Duck &#123;</span><br><span class="line">    public RedHeadDuck()&#123;</span><br><span class="line">        quackBehavior &#x3D; new BadQuackBehavior();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;我是独一无二的,我的头是红色的&quot;);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>SimulateDuck.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主类：模拟鸭子</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SimulateDuck &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;父类为Duck,屏蔽了超类的差别性</span><br><span class="line">       Duck greenHeadDuck &#x3D; new GreenHeadDuck();</span><br><span class="line">        Duck redHeadDuck&#x3D;new RedHeadDuck();</span><br><span class="line">&#x2F;&#x2F;        GreenHeadDuck greenHeadDuck &#x3D; new GreenHeadDuck();</span><br><span class="line">&#x2F;&#x2F;        RedHeadDuck redHeadDuck &#x3D; new RedHeadDuck();</span><br><span class="line">        greenHeadDuck.display();</span><br><span class="line">        greenHeadDuck.fly();</span><br><span class="line">        greenHeadDuck.SetQuackBehavior(new QuackBehavior() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void quack() &#123;</span><br><span class="line">                System.out.println(&quot;我会叫&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        greenHeadDuck.swim();</span><br><span class="line"></span><br><span class="line">        redHeadDuck.display();</span><br><span class="line">        redHeadDuck.quack();</span><br><span class="line">        redHeadDuck.swim();</span><br><span class="line">        redHeadDuck.SetFlyBehavior(new FlyBehavior() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void fly() &#123;</span><br><span class="line">                System.out.println(&quot;我会飞&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FlyBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FlyBehavior &#123;</span><br><span class="line">    void fly();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>QuackBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface QuackBehavior &#123;</span><br><span class="line">    void quack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BadFlyBehavior.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BadFlyBehavior implements FlyBehavior&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        System.out.println(&quot;我不会飞&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BadQuackBehavio.java:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BadQuackBehavior  implements QuackBehavior&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void quack() &#123;</span><br><span class="line">        System.out.println(&quot;我不会叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总结：运用设计模式中的策略模式，把变化的部分提取出来变为接口+实现。</strong></p>
<p><strong>Duck类中的SetQuackBehavoir()方法，灵活的让实例化对象灵活的改变对象的行为。比如，绿头鸭，使用了SetQuackBehavoir（）方法，定制了自己的quck()方法。因为不是每只鸭都能叫的。叫的是当前鸭的特性。</strong></p>
<h3 id="4-设计原则"><a href="#4-设计原则" class="headerlink" title="4.设计原则"></a>4.设计原则</h3><p>策略模式体现了几个<strong>设计原则</strong></p>
<ul>
<li><p>封装变化：把变化的代码从不变的代码中分离出来（找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起。）</p>
</li>
<li><p>针对接口编程而不是具体类（定义了策略接口）</p>
</li>
<li><p>多用组合/聚合，少用继承（客户通过组合方式使用策略）</p>
</li>
</ul>
<h3 id="5-价格计算问题"><a href="#5-价格计算问题" class="headerlink" title="5.价格计算问题"></a>5.价格计算问题</h3><p>以一个价格计算策略为背景</p>
<p><strong>没有用策略模式</strong></p>
<p>我们一般是下面的写法,直接写一个类,在类里面直接写策略算法(功能实现)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class NoStrategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 传入客服等级类型获取相应的价格</span><br><span class="line">     * @param type   会员类型(等级)</span><br><span class="line">     * @param price  响应的价格</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public double getPrice(String type, double price) &#123;</span><br><span class="line"></span><br><span class="line">        if (&quot;普通客户小批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 不打折,原价&quot;);</span><br><span class="line">            return price;</span><br><span class="line">        &#125; else if (&quot;普通客户大批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打九折&quot;);</span><br><span class="line">            return price * 0.9;</span><br><span class="line">        &#125; else if (&quot;老客户小批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打八折&quot;);</span><br><span class="line">            return price * 0.8;</span><br><span class="line">        &#125; else if (&quot;老客户大批量&quot;.equals(type)) &#123;</span><br><span class="line">            System.out.println(&quot;[未采用设计模式] 打七折&quot;);</span><br><span class="line">            return price * 0.7;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;拓展一种策略</span><br><span class="line">   &#x2F;&#x2F;     &#125;else if(&quot;老客户特大批量&quot;.equals(type))&#123;</span><br><span class="line">   &#x2F;&#x2F;        System.out.println(&quot;[未采用设计模式] 打六折&quot;);</span><br><span class="line">   &#x2F;&#x2F;         return price*0.6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;乱传的也是当普通客户小批量(就是不打折)</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NoStrategy:没有策略的做法</li>
<li>实现起来比较容易，符合一般开发人员的思路</li>
<li>假如，类型特别多，算法比较复杂时，整个条件语句的代码就变得很长，难于维护。</li>
<li>如果有新增类型，就需要频繁的修改此处的代码！</li>
<li>不符合开闭原则！—对这个类的修改要关闭,就是这个类要是写好了就不要去改他了,对类的功能的拓展要开放,显然只有面向接口编程才满足,</li>
<li>所以应用策略模式Strategy这个接口</li>
</ul>
<h3 id="6-策略模式解决价格计算问题"><a href="#6-策略模式解决价格计算问题" class="headerlink" title="6.策略模式解决价格计算问题"></a>6.策略模式解决价格计算问题</h3><p>1.写一个策略接口Strategy</p>
<ul>
<li>Strategy:策略接口</li>
<li>这个是对类NoStrategy改成面向接口的方式实现策略,不像NoStrategy一样,直接写死策略的实现,而是使用这个接口先定义策略</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 通过策略获取价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    double getPrice(double standardPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.面向接口,组合编程,少用继承(继承虽然可以复用代码,但是会造成耦合度增加,解决方式往往采用接口做类的属性),如下,这样所有实现Strategy 的各种策略实现类都”组合”到这个类里面了</p>
<ul>
<li>Context:策略模式上下文—策略接收器,专门接收策略实现的算法</li>
<li>负责和具体的策略类交互</li>
<li>这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。</li>
<li>如果使用spring的依赖注入功能，还可以通过配置文件，动态的注入不同策略对象，动态的切换不同的算法.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 当前采用的算法对象</span><br><span class="line">     * 面向接口,组合编程,少用继承</span><br><span class="line">     * 简言之复杂类型(类,接口等)做属性</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    public Context(Strategy strategy) &#123;</span><br><span class="line"></span><br><span class="line">        this.strategy &#x3D; strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getReultPrice(double price)&#123;</span><br><span class="line"></span><br><span class="line">        return this.strategy.getPrice(price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3:既然是策略模式接口Strategy都明确了要做的事情是根据会员情况,返回价格,但是没有真正的实现,那么总有类来实现赛</p>
<p>策略实现类1  VIP0Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP0Strategy:普通会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP0Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP0Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]普通会员 原价:&quot;+standardPrice);</span><br><span class="line">        return standardPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类2  VIP1Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP1Strategy: 一级会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP1Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP1Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]一级会员 打九折：&quot;+standardPrice * 0.9);</span><br><span class="line">        return standardPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类3  VIP2Strategy </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * VIP2Strategy:二级会员策略</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class VIP2Strategy implements Strategy &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 输入一个价格,经过VIP2Strategy策略计算价格</span><br><span class="line">     * @param standardPrice</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]二级会员八折:&quot;+standardPrice*0.8);</span><br><span class="line">        return standardPrice*0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>策略实现类4 VIP3Strategy(新增加的需求) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class VIP3Strategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double getPrice(double standardPrice) &#123;</span><br><span class="line">        System.out.println(&quot;[策略模式]老客户特大批量:&quot;+standardPrice*0.6);</span><br><span class="line">        return standardPrice*0.6;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>4.客户端：</p>
<ul>
<li>Client:策略模式客户端—Client 的main方法 可以想象成我们在使用别人写好的框架,我们有新的需求,对框架开发者来说就是需要对已有的</li>
<li>代码进行维护升级,比如此时我们修改NoStrategy类,那么修改完后新版本的框架NoStrategy类很有能是对已经在使用的客户机制上不兼容的,如果用户升级为新版框架,遇到使用NoStrategy类的会报错,各种不兼容就不符合开发者维护的版本的规范,所以修改已有的类是极其不科学的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import com.cx.price.NoStrategy;</span><br><span class="line">import com.cx.price.VIP1Strategy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;未使用模式-----------------------------------------&quot;);</span><br><span class="line">        NoStrategy noStrategy &#x3D; new NoStrategy();</span><br><span class="line">        double price &#x3D; noStrategy.getPrice(&quot;普通客户大批量&quot;, 1000);</span><br><span class="line">        System.out.println(price);</span><br><span class="line">        System.out.println(&quot;\n测试策略------------------------------------------&quot;);</span><br><span class="line">        Context context0 &#x3D; new Context(new VIP1Strategy());</span><br><span class="line">        double resultPrice &#x3D; context0.getReultPrice(1000);</span><br><span class="line">        System.out.println(resultPrice);</span><br><span class="line">&#x2F;&#x2F;怎么体现策略模式呢?比如现在需求是增加一种会员机制,  &#39;老客户特大批量&#39; ，那么显然打折力度更大,我们设置为6折,</span><br><span class="line">&#x2F;&#x2F; 分别在未使用策略模式和使用了策略模式的基础上拓展,看那个更加易于拓展,方便维护</span><br><span class="line">        &#x2F;&#x2F;为了实现这么一个折扣计算功能，代码需要写4个if-else，如果需求再增多一个规则，代码还需重构if-else，这样在可维护性、可读性大大降低，而且修改容易出bug。</span><br><span class="line">        &#x2F;&#x2F;如果运用策略模式，每个规则对应一个策略，根据符合的条件对应选择哪一种策略，这样整体代码逻辑清晰，而且不管新增或修改规则时，只需要新增或调整对应的规则策略，这样大大降低bug的风险，可维护性更高。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;新增策略后未使用模式(会修该策略核心类)</span><br><span class="line">&#x2F;&#x2F;        NoStrategy noStrategy1 &#x3D; new NoStrategy();</span><br><span class="line">&#x2F;&#x2F;        double price1 &#x3D; noStrategy1.getPrice(&quot;老客户特大批量&quot;, 1000);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(price1);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;        &#x2F;&#x2F;新增策略后使用模式(不会修改策略接口,只是添加一个实现)</span><br><span class="line">&#x2F;&#x2F;        Context context2 &#x3D; new Context(new VIP3Strategy());</span><br><span class="line">&#x2F;&#x2F;        double price2 &#x3D; context2.getReultPrice(1000);</span><br><span class="line">&#x2F;&#x2F;        System.out.println(price2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结论：   修改服务器端已经写好了的类是极其不好的维护形式,因为这个类NoStrategy可能在别的类中作为依赖或者叫做别的类引用了该类,在不明确的情况下,可能牵一发动全身,是不好的维护方式,使用了策略模式，我们只是添加了一个策略接口的实现,低侵入式,不会对已有代码造成影响,低耦合</p>
<h3 id="7-策略模式原理类图"><a href="#7-策略模式原理类图" class="headerlink" title="7.策略模式原理类图"></a>7.策略模式原理类图</h3><p>说明：从上面这个图可以看出来客户context有成员变量strategy或者其他的策略接口，至于需要使用到哪个策略，我们可以在构造器中指定</p>
<p>策略模式的主要角色如下：</p>
<ol>
<li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ol>
<h3 id="8-策略模式的总结"><a href="#8-策略模式的总结" class="headerlink" title="8.策略模式的总结"></a>8.策略模式的总结</h3><p>1）策略模式的关键是 ：<strong>分析项目中变化部分与不变部分</strong><br>2）策略模式的核心思想是 ：多用组合/聚合，少用继承；用行为类组合，而不是行为的继承。更有弹性。<br>3）体现了“开闭原则”(对修改关闭，对扩展开放)。客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if…else if … else)；<br>4）提供了可以替换继承关心的办法 ：策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展。<br>5）需要注意的是 ：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" data-id="ckjcfcev500012oul0q5gdy8t" data-title="策略模式" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/hello-world1/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T04:10:33.933Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/31/hello-world1/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/hello-world1/" data-id="ckjcfceui00002oulene2ec15" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/31/hello-world/" class="article-date">
  <time class="dt-published" datetime="2020-12-31T02:58:57.175Z" itemprop="datePublished">2020-12-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/31/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/31/hello-world/" data-id="ckjca1cff0000v4ul0gjbg35u" data-title="Hello World" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/06/%E7%BF%BB%E8%AF%91/">翻译</a>
          </li>
        
          <li>
            <a href="/2021/01/06/%E7%90%86%E8%A7%A3/">对Okta的相关理解</a>
          </li>
        
          <li>
            <a href="/2021/01/01/github%20pages/">GitHub Pages搭建博客详解</a>
          </li>
        
          <li>
            <a href="/2020/12/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
          </li>
        
          <li>
            <a href="/2020/12/31/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>